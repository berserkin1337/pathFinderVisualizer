{"ast":null,"code":"import _defineProperty from \"/home/aviral/temp/pathFinderVisualizer/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/home/aviral/temp/pathFinderVisualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { AStar } from \"../algorithms/aStar\";\nimport { dfs } from \"../algorithms/dfs\";\nimport { bfs } from \"../algorithms/bfs\";\nimport \"./PathfindingVisualizer.css\";\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n\n    this.getInitialGrid = (rowCount = this.state.ROW_COUNT, colCount = this.state.COLUMN_COUNT) => {\n      const initialGrid = [];\n\n      for (let row = 0; row < rowCount; row++) {\n        const currentRow = [];\n\n        for (let col = 0; col < colCount; col++) {\n          currentRow.push(this.createNode(row, col));\n        }\n\n        initialGrid.push(currentRow);\n      }\n\n      return initialGrid;\n    };\n\n    this.createNode = (row, col) => {\n      return {\n        row,\n        col,\n        isStart: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\n        isFinish: row === this.state.FINISH_NODE_ROW && col === this.state.FINISH_NODE_COL,\n        distance: Infinity,\n        distanceToFinishNode: Math.abs(this.state.FINISH_NODE_ROW - row) + Math.abs(this.state.FINISH_NODE_COL - col),\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        isNode: true\n      };\n    };\n\n    this.state = {\n      grid: [],\n      START_NODE_ROW: 5,\n      FINISH_NODE_ROW: 5,\n      START_NODE_COL: 5,\n      FINISH_NODE_COL: 15,\n      mouseIsPressed: false,\n      ROW_COUNT: 25,\n      COLUMN_COUNT: 35,\n      MOBILE_ROW_COUNT: 10,\n      MOBILE_COLUMN_COUNT: 20,\n      isRunning: false,\n      isStartNode: false,\n      isFinishNode: false,\n      isWallNode: false,\n      // xxxxxxx\n      currRow: 0,\n      currCol: 0,\n      isDesktopView: true\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n\n  toggleIsRunning() {\n    this.setState({\n      isRunning: !this.state.isRunning\n    });\n  }\n\n  toggleView() {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.clearWalls();\n      const isDesktopView = !this.state.isDesktopView;\n      let grid;\n\n      if (isDesktopView) {\n        grid = this.getInitialGrid(this.state.ROW_COUNT, this.state.COLUMN_COUNT);\n        this.setState({\n          isDesktopView,\n          grid\n        });\n      } else {\n        if (this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT || this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT || this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT) {\n          alert(\"Start & Finish Nodes Must Be within 10 Rows x 20 Columns\");\n        } else {\n          grid = this.getInitialGrid(this.state.MOBILE_ROW_COUNT, this.state.MOBILE_COLUMN_COUNT);\n          this.setState({\n            isDesktopView,\n            grid\n          });\n        }\n      }\n    }\n  }\n  /******************** Set up the initial grid ********************/\n\n\n  /******************** Control mouse events ********************/\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className === \"node node-start\") {\n          this.setState({\n            mouseIsPressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else if (document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className === \"node node-finish\") {\n          this.setState({\n            mouseIsPressed: true,\n            isFinishNode: true,\n            currRow: row,\n            currCol: col\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n        if (nodeClassName === \"node node-visited\" || nodeClassName === \"node node-shortest-path\") {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.mouseIsPressed) {\n        const nodeClassName = document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className;\n\n        if (this.state.isStartNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevStartNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevStartNode.isStart = false;\n            document.getElementById(\"node-\".concat(this.state.currRow, \"-\").concat(this.state.currCol)).className = \"node\";\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currStartNode = this.state.grid[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className = \"node node-start\";\n          }\n\n          this.setState({\n            START_NODE_ROW: row,\n            START_NODE_COL: col\n          });\n        } else if (this.state.isFinishNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevFinishNode = this.state.grid[this.state.currRow][this.state.currCol];\n            prevFinishNode.isFinish = false;\n            document.getElementById(\"node-\".concat(this.state.currRow, \"-\").concat(this.state.currCol)).className = \"node\";\n            this.setState({\n              currRow: row,\n              currCol: col\n            });\n            const currFinishNode = this.state.grid[row][col];\n            currFinishNode.isFinish = true;\n            document.getElementById(\"node-\".concat(row, \"-\").concat(col)).className = \"node node-finish\";\n          }\n\n          this.setState({\n            FINISH_NODE_ROW: row,\n            FINISH_NODE_COL: col\n          });\n        } else if (this.state.isWallNode) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({\n        mouseIsPressed: false\n      });\n\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({\n          isStartNode,\n          START_NODE_ROW: row,\n          START_NODE_COL: col\n        });\n      } else if (this.state.isFinishNode) {\n        const isFinishNode = !this.state.isFinishNode;\n        this.setState({\n          isFinishNode,\n          FINISH_NODE_ROW: row,\n          FINISH_NODE_COL: col\n        });\n      }\n\n      this.getInitialGrid();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({\n        isStartNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isFinishNode) {\n      const isFinishNode = !this.state.isFinishNode;\n      this.setState({\n        isFinishNode,\n        mouseIsPressed: false\n      });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({\n        isWallNode,\n        mouseIsPressed: false\n      });\n      this.getInitialGrid();\n    }\n  }\n  /******************** Clear Board/Walls ********************/\n\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName !== \"node node-start\" && nodeClassName !== \"node node-finish\" && nodeClassName !== \"node node-wall\") {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = \"node\";\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n          }\n\n          if (nodeClassName === \"node node-finish\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n\n          if (nodeClassName === \"node node-start\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = Math.abs(this.state.FINISH_NODE_ROW - node.row) + Math.abs(this.state.FINISH_NODE_COL - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  clearWalls() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.grid.slice();\n\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName === \"node node-wall\") {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = \"node\";\n            node.isWall = false;\n          }\n        }\n      }\n    }\n  }\n  /******************** Create Animations ********************/\n\n\n  visualize(algo) {\n    if (!this.state.isRunning) {\n      this.clearGrid();\n      this.toggleIsRunning();\n      const grid = this.state.grid;\n      const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\n      const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\n      let visitedNodesInOrder;\n\n      switch (algo) {\n        case \"Dijkstra\":\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n          break;\n\n        case \"AStar\":\n          visitedNodesInOrder = AStar(grid, startNode, finishNode);\n          break;\n\n        case \"BFS\":\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\n          break;\n\n        case \"DFS\":\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\n          break;\n\n        default:\n          // should never get here\n          break;\n      }\n\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      nodesInShortestPathOrder.push(\"end\");\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n        if (nodeClassName !== \"node node-start\" && nodeClassName !== \"node node-finish\") {\n          document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n  /******************** Create path from start to finish ********************/\n\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === \"end\") {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className;\n\n          if (nodeClassName !== \"node node-start\" && nodeClassName !== \"node node-finish\") {\n            document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = \"node node-shortest-path\";\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  render() {\n    const _this$state = this.state,\n          grid = _this$state.grid,\n          mouseIsPressed = _this$state.mouseIsPressed;\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 427\n      },\n      __self: this\n    }, React.createElement(\"nav\", {\n      className: \"navbar navbar-expand-lg navbar-dark bg-dark \",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 428\n      },\n      __self: this\n    }, React.createElement(\"a\", {\n      className: \"navbar-brand\",\n      href: \"/\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 429\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 430\n      },\n      __self: this\n    }, \"PathFinding Visualizer\")), React.createElement(\"button\", {\n      className: \"navbar-toggler\",\n      type: \"button\",\n      \"data-toggle\": \"collapse\",\n      \"data-target\": \"#navbarNav\",\n      \"aria-controls\": \"navbarNav\",\n      \"aria-expanded\": \"false\",\n      \"aria-label\": \"Toggle navigation\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 432\n      },\n      __self: this\n    }, React.createElement(\"span\", {\n      className: \"navbar-toggler-icon\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 441\n      },\n      __self: this\n    })), React.createElement(\"div\", {\n      className: \"collapse navbar-collapse\",\n      id: \"navbarNav\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 443\n      },\n      __self: this\n    }, React.createElement(\"ul\", {\n      className: \"navbar-nav\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 444\n      },\n      __self: this\n    }))), React.createElement(\"table\", {\n      className: \"grid-container\",\n      onMouseLeave: () => this.handleMouseLeave(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 448\n      },\n      __self: this\n    }, React.createElement(\"tbody\", {\n      className: \"grid\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 452\n      },\n      __self: this\n    }, grid.map((row, rowIdx) => {\n      return React.createElement(\"tr\", {\n        key: rowIdx,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 455\n        },\n        __self: this\n      }, row.map((node, nodeIdx) => {\n        const row = node.row,\n              col = node.col,\n              isFinish = node.isFinish,\n              isStart = node.isStart,\n              isWall = node.isWall;\n        return React.createElement(Node, {\n          key: nodeIdx,\n          col: col,\n          isFinish: isFinish,\n          isStart: isStart,\n          isWall: isWall,\n          mouseIsPressed: mouseIsPressed,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(row, col),\n          row: row,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 465\n          },\n          __self: this\n        });\n      }));\n    }))), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-danger\",\n      onClick: () => this.clearGrid(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 496\n      },\n      __self: this\n    }, \"Clear Grid\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-warning\",\n      onClick: () => this.clearWalls(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 503\n      },\n      __self: this\n    }, \"Clear Walls\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize(\"Dijkstra\"),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 510\n      },\n      __self: this\n    }, \"Dijkstra's\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize(\"AStar\"),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 517\n      },\n      __self: this\n    }, \"A*\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize(\"BFS\"),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 524\n      },\n      __self: this\n    }, \"Bread First Search\"), React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-primary\",\n      onClick: () => this.visualize(\"DFS\"),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 531\n      },\n      __self: this\n    }, \"Depth First Search\"), this.state.isDesktopView ? React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-light\",\n      onClick: () => this.toggleView(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 539\n      },\n      __self: this\n    }, \"Mobile View\") : React.createElement(\"button\", {\n      type: \"button\",\n      className: \"btn btn-dark\",\n      onClick: () => this.toggleView(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 547\n      },\n      __self: this\n    }, \"Desktop View\"));\n  }\n\n}\n/******************** Create Walls ********************/\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  if (!node.isStart && !node.isFinish && node.isNode) {\n    const newNode = _objectSpread({}, node, {\n      isWall: !node.isWall\n    });\n\n    newGrid[row][col] = newNode;\n  }\n\n  return newGrid;\n}; // Backtracks from the finishNode to find the shortest path.\n// Only works when called after the pathfinding methods.\n\n\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/home/aviral/temp/pathFinderVisualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx"],"names":["React","Component","Node","dijkstra","AStar","dfs","bfs","PathfindingVisualizer","constructor","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","row","currentRow","col","push","createNode","isStart","START_NODE_ROW","START_NODE_COL","isFinish","FINISH_NODE_ROW","FINISH_NODE_COL","distance","Infinity","distanceToFinishNode","Math","abs","isVisited","isWall","previousNode","isNode","grid","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","componentDidMount","setState","toggleView","clearGrid","clearWalls","alert","isGridClear","document","getElementById","className","newGrid","getNewGridWithWallToggled","node","nodeClassName","handleMouseEnter","prevStartNode","currStartNode","prevFinishNode","currFinishNode","handleMouseUp","slice","visualize","algo","startNode","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","i","length","setTimeout","animateShortestPath","render","map","rowIdx","nodeIdx","newNode","currentNode","unshift"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra } from \"../algorithms/dijkstra\";\r\nimport { AStar } from \"../algorithms/aStar\";\r\nimport { dfs } from \"../algorithms/dfs\";\r\nimport { bfs } from \"../algorithms/bfs\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid: [],\r\n            START_NODE_ROW: 5,\r\n            FINISH_NODE_ROW: 5,\r\n            START_NODE_COL: 5,\r\n            FINISH_NODE_COL: 15,\r\n            mouseIsPressed: false,\r\n            ROW_COUNT: 25,\r\n            COLUMN_COUNT: 35,\r\n            MOBILE_ROW_COUNT: 10,\r\n            MOBILE_COLUMN_COUNT: 20,\r\n            isRunning: false,\r\n            isStartNode: false,\r\n            isFinishNode: false,\r\n            isWallNode: false, // xxxxxxx\r\n            currRow: 0,\r\n            currCol: 0,\r\n            isDesktopView: true,\r\n        };\r\n\r\n        this.handleMouseDown = this.handleMouseDown.bind(this);\r\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n        this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = this.getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    toggleIsRunning() {\r\n        this.setState({ isRunning: !this.state.isRunning });\r\n    }\r\n\r\n    toggleView() {\r\n        if (!this.state.isRunning) {\r\n            this.clearGrid();\r\n            this.clearWalls();\r\n            const isDesktopView = !this.state.isDesktopView;\r\n            let grid;\r\n            if (isDesktopView) {\r\n                grid = this.getInitialGrid(\r\n                    this.state.ROW_COUNT,\r\n                    this.state.COLUMN_COUNT\r\n                );\r\n                this.setState({ isDesktopView, grid });\r\n            } else {\r\n                if (\r\n                    this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n                    this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n                    this.state.START_NODE_COL >\r\n                        this.state.MOBILE_COLUMN_COUNT ||\r\n                    this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\r\n                ) {\r\n                    alert(\r\n                        \"Start & Finish Nodes Must Be within 10 Rows x 20 Columns\"\r\n                    );\r\n                } else {\r\n                    grid = this.getInitialGrid(\r\n                        this.state.MOBILE_ROW_COUNT,\r\n                        this.state.MOBILE_COLUMN_COUNT\r\n                    );\r\n                    this.setState({ isDesktopView, grid });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /******************** Set up the initial grid ********************/\r\n    getInitialGrid = (\r\n        rowCount = this.state.ROW_COUNT,\r\n        colCount = this.state.COLUMN_COUNT\r\n    ) => {\r\n        const initialGrid = [];\r\n        for (let row = 0; row < rowCount; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < colCount; col++) {\r\n                currentRow.push(this.createNode(row, col));\r\n            }\r\n            initialGrid.push(currentRow);\r\n        }\r\n        return initialGrid;\r\n    };\r\n\r\n    createNode = (row, col) => {\r\n        return {\r\n            row,\r\n            col,\r\n            isStart:\r\n                row === this.state.START_NODE_ROW &&\r\n                col === this.state.START_NODE_COL,\r\n            isFinish:\r\n                row === this.state.FINISH_NODE_ROW &&\r\n                col === this.state.FINISH_NODE_COL,\r\n            distance: Infinity,\r\n            distanceToFinishNode:\r\n                Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n                Math.abs(this.state.FINISH_NODE_COL - col),\r\n            isVisited: false,\r\n            isWall: false,\r\n            previousNode: null,\r\n            isNode: true,\r\n        };\r\n    };\r\n\r\n    /******************** Control mouse events ********************/\r\n    handleMouseDown(row, col) {\r\n        if (!this.state.isRunning) {\r\n            if (this.isGridClear()) {\r\n                if (\r\n                    document.getElementById(`node-${row}-${col}`).className ===\r\n                    \"node node-start\"\r\n                ) {\r\n                    this.setState({\r\n                        mouseIsPressed: true,\r\n                        isStartNode: true,\r\n                        currRow: row,\r\n                        currCol: col,\r\n                    });\r\n                } else if (\r\n                    document.getElementById(`node-${row}-${col}`).className ===\r\n                    \"node node-finish\"\r\n                ) {\r\n                    this.setState({\r\n                        mouseIsPressed: true,\r\n                        isFinishNode: true,\r\n                        currRow: row,\r\n                        currCol: col,\r\n                    });\r\n                } else {\r\n                    const newGrid = getNewGridWithWallToggled(\r\n                        this.state.grid,\r\n                        row,\r\n                        col\r\n                    );\r\n                    this.setState({\r\n                        grid: newGrid,\r\n                        mouseIsPressed: true,\r\n                        isWallNode: true,\r\n                        currRow: row,\r\n                        currCol: col,\r\n                    });\r\n                }\r\n            } else {\r\n                this.clearGrid();\r\n            }\r\n        }\r\n    }\r\n\r\n    isGridClear() {\r\n        for (const row of this.state.grid) {\r\n            for (const node of row) {\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${node.row}-${node.col}`\r\n                ).className;\r\n                if (\r\n                    nodeClassName === \"node node-visited\" ||\r\n                    nodeClassName === \"node node-shortest-path\"\r\n                ) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.isRunning) {\r\n            if (this.state.mouseIsPressed) {\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${row}-${col}`\r\n                ).className;\r\n                if (this.state.isStartNode) {\r\n                    if (nodeClassName !== \"node node-wall\") {\r\n                        const prevStartNode =\r\n                            this.state.grid[this.state.currRow][\r\n                                this.state.currCol\r\n                            ];\r\n                        prevStartNode.isStart = false;\r\n                        document.getElementById(\r\n                            `node-${this.state.currRow}-${this.state.currCol}`\r\n                        ).className = \"node\";\r\n\r\n                        this.setState({ currRow: row, currCol: col });\r\n                        const currStartNode = this.state.grid[row][col];\r\n                        currStartNode.isStart = true;\r\n                        document.getElementById(\r\n                            `node-${row}-${col}`\r\n                        ).className = \"node node-start\";\r\n                    }\r\n                    this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\r\n                } else if (this.state.isFinishNode) {\r\n                    if (nodeClassName !== \"node node-wall\") {\r\n                        const prevFinishNode =\r\n                            this.state.grid[this.state.currRow][\r\n                                this.state.currCol\r\n                            ];\r\n                        prevFinishNode.isFinish = false;\r\n                        document.getElementById(\r\n                            `node-${this.state.currRow}-${this.state.currCol}`\r\n                        ).className = \"node\";\r\n\r\n                        this.setState({ currRow: row, currCol: col });\r\n                        const currFinishNode = this.state.grid[row][col];\r\n                        currFinishNode.isFinish = true;\r\n                        document.getElementById(\r\n                            `node-${row}-${col}`\r\n                        ).className = \"node node-finish\";\r\n                    }\r\n                    this.setState({\r\n                        FINISH_NODE_ROW: row,\r\n                        FINISH_NODE_COL: col,\r\n                    });\r\n                } else if (this.state.isWallNode) {\r\n                    const newGrid = getNewGridWithWallToggled(\r\n                        this.state.grid,\r\n                        row,\r\n                        col\r\n                    );\r\n                    this.setState({ grid: newGrid });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (!this.state.isRunning) {\r\n            this.setState({ mouseIsPressed: false });\r\n            if (this.state.isStartNode) {\r\n                const isStartNode = !this.state.isStartNode;\r\n                this.setState({\r\n                    isStartNode,\r\n                    START_NODE_ROW: row,\r\n                    START_NODE_COL: col,\r\n                });\r\n            } else if (this.state.isFinishNode) {\r\n                const isFinishNode = !this.state.isFinishNode;\r\n                this.setState({\r\n                    isFinishNode,\r\n                    FINISH_NODE_ROW: row,\r\n                    FINISH_NODE_COL: col,\r\n                });\r\n            }\r\n            this.getInitialGrid();\r\n        }\r\n    }\r\n\r\n    handleMouseLeave() {\r\n        if (this.state.isStartNode) {\r\n            const isStartNode = !this.state.isStartNode;\r\n            this.setState({ isStartNode, mouseIsPressed: false });\r\n        } else if (this.state.isFinishNode) {\r\n            const isFinishNode = !this.state.isFinishNode;\r\n            this.setState({ isFinishNode, mouseIsPressed: false });\r\n        } else if (this.state.isWallNode) {\r\n            const isWallNode = !this.state.isWallNode;\r\n            this.setState({ isWallNode, mouseIsPressed: false });\r\n            this.getInitialGrid();\r\n        }\r\n    }\r\n\r\n    /******************** Clear Board/Walls ********************/\r\n\r\n    clearGrid() {\r\n        if (!this.state.isRunning) {\r\n            const newGrid = this.state.grid.slice();\r\n            for (const row of newGrid) {\r\n                for (const node of row) {\r\n                    let nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`\r\n                    ).className;\r\n                    if (\r\n                        nodeClassName !== \"node node-start\" &&\r\n                        nodeClassName !== \"node node-finish\" &&\r\n                        nodeClassName !== \"node node-wall\"\r\n                    ) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = \"node\";\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode =\r\n                            Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n                            Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n                    }\r\n                    if (nodeClassName === \"node node-finish\") {\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode = 0;\r\n                    }\r\n                    if (nodeClassName === \"node node-start\") {\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode =\r\n                            Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n                            Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n                        node.isStart = true;\r\n                        node.isWall = false;\r\n                        node.previousNode = null;\r\n                        node.isNode = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearWalls() {\r\n        if (!this.state.isRunning) {\r\n            const newGrid = this.state.grid.slice();\r\n            for (const row of newGrid) {\r\n                for (const node of row) {\r\n                    let nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`\r\n                    ).className;\r\n                    if (nodeClassName === \"node node-wall\") {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = \"node\";\r\n                        node.isWall = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /******************** Create Animations ********************/\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            this.clearGrid();\r\n            this.toggleIsRunning();\r\n            const { grid } = this.state;\r\n            const startNode =\r\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode =\r\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            let visitedNodesInOrder;\r\n            switch (algo) {\r\n                case \"Dijkstra\":\r\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                    break;\r\n                case \"AStar\":\r\n                    visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n                    break;\r\n                case \"BFS\":\r\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n                    break;\r\n                case \"DFS\":\r\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n                    break;\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n            const nodesInShortestPathOrder =\r\n                getNodesInShortestPathOrder(finishNode);\r\n            nodesInShortestPathOrder.push(\"end\");\r\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n    }\r\n\r\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${node.row}-${node.col}`\r\n                ).className;\r\n                if (\r\n                    nodeClassName !== \"node node-start\" &&\r\n                    nodeClassName !== \"node node-finish\"\r\n                ) {\r\n                    document.getElementById(\r\n                        `node-${node.row}-${node.col}`\r\n                    ).className = \"node node-visited\";\r\n                }\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    /******************** Create path from start to finish ********************/\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if (nodesInShortestPathOrder[i] === \"end\") {\r\n                setTimeout(() => {\r\n                    this.toggleIsRunning();\r\n                }, i * 50);\r\n            } else {\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    const nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`\r\n                    ).className;\r\n                    if (\r\n                        nodeClassName !== \"node node-start\" &&\r\n                        nodeClassName !== \"node node-finish\"\r\n                    ) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = \"node node-shortest-path\";\r\n                    }\r\n                }, i * 40);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed } = this.state;\r\n        return (\r\n            <div>\r\n                <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark \">\r\n                    <a className=\"navbar-brand\" href=\"/\">\r\n                        <b>PathFinding Visualizer</b>\r\n                    </a>\r\n                    <button\r\n                        className=\"navbar-toggler\"\r\n                        type=\"button\"\r\n                        data-toggle=\"collapse\"\r\n                        data-target=\"#navbarNav\"\r\n                        aria-controls=\"navbarNav\"\r\n                        aria-expanded=\"false\"\r\n                        aria-label=\"Toggle navigation\"\r\n                    >\r\n                        <span className=\"navbar-toggler-icon\"></span>\r\n                    </button>\r\n                    <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\r\n                        <ul className=\"navbar-nav\"></ul>\r\n                    </div>\r\n                </nav>\r\n\r\n                <table\r\n                    className=\"grid-container\"\r\n                    onMouseLeave={() => this.handleMouseLeave()}\r\n                >\r\n                    <tbody className=\"grid\">\r\n                        {grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <tr key={rowIdx}>\r\n                                    {row.map((node, nodeIdx) => {\r\n                                        const {\r\n                                            row,\r\n                                            col,\r\n                                            isFinish,\r\n                                            isStart,\r\n                                            isWall,\r\n                                        } = node;\r\n                                        return (\r\n                                            <Node\r\n                                                key={nodeIdx}\r\n                                                col={col}\r\n                                                isFinish={isFinish}\r\n                                                isStart={isStart}\r\n                                                isWall={isWall}\r\n                                                mouseIsPressed={mouseIsPressed}\r\n                                                onMouseDown={(row, col) =>\r\n                                                    this.handleMouseDown(\r\n                                                        row,\r\n                                                        col\r\n                                                    )\r\n                                                }\r\n                                                onMouseEnter={(row, col) =>\r\n                                                    this.handleMouseEnter(\r\n                                                        row,\r\n                                                        col\r\n                                                    )\r\n                                                }\r\n                                                onMouseUp={() =>\r\n                                                    this.handleMouseUp(row, col)\r\n                                                }\r\n                                                row={row}\r\n                                            ></Node>\r\n                                        );\r\n                                    })}\r\n                                </tr>\r\n                            );\r\n                        })}\r\n                    </tbody>\r\n                </table>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-danger\"\r\n                    onClick={() => this.clearGrid()}\r\n                >\r\n                    Clear Grid\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-warning\"\r\n                    onClick={() => this.clearWalls()}\r\n                >\r\n                    Clear Walls\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-primary\"\r\n                    onClick={() => this.visualize(\"Dijkstra\")}\r\n                >\r\n                    Dijkstra's\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-primary\"\r\n                    onClick={() => this.visualize(\"AStar\")}\r\n                >\r\n                    A*\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-primary\"\r\n                    onClick={() => this.visualize(\"BFS\")}\r\n                >\r\n                    Bread First Search\r\n                </button>\r\n                <button\r\n                    type=\"button\"\r\n                    className=\"btn btn-primary\"\r\n                    onClick={() => this.visualize(\"DFS\")}\r\n                >\r\n                    Depth First Search\r\n                </button>\r\n                {this.state.isDesktopView ? (\r\n                    <button\r\n                        type=\"button\"\r\n                        className=\"btn btn-light\"\r\n                        onClick={() => this.toggleView()}\r\n                    >\r\n                        Mobile View\r\n                    </button>\r\n                ) : (\r\n                    <button\r\n                        type=\"button\"\r\n                        className=\"btn btn-dark\"\r\n                        onClick={() => this.toggleView()}\r\n                    >\r\n                        Desktop View\r\n                    </button>\r\n                )}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (!node.isStart && !node.isFinish && node.isNode) {\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the pathfinding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}